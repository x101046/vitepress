<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | My Awesome Project</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.2.2">
    <link rel="preload stylesheet" href="/vitepress/assets/style.CX3kw4yQ.css" as="style">
    
    <script type="module" src="/vitepress/assets/app.CW3PBbL5.js"></script>
    <link rel="preload" href="/vitepress/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/vitepress/assets/chunks/framework.CDiOzltk.js">
    <link rel="modulepreload" href="/vitepress/assets/chunks/theme.CUh00J8l.js">
    <link rel="modulepreload" href="/vitepress/assets/chunks/img2.B7KNQ0Me.js">
    <link rel="modulepreload" href="/vitepress/assets/chunks/img7.k_v_EIIq.js">
    <link rel="modulepreload" href="/vitepress/assets/q_a_network_index.md.DjUG-bE4.lean.js">
    <link rel="icon" href="/img/logo.png">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><!--[--><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar has-sidebar top" data-v-ae24b3ad data-v-ccf7ddec><div class="wrapper" data-v-ccf7ddec><div class="container" data-v-ccf7ddec><div class="title" data-v-ccf7ddec><div class="VPNavBarTitle has-sidebar" data-v-ccf7ddec data-v-ab179fa1><a class="title" href="/vitepress/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>My Awesome Project</span><!--[--><!--]--></a></div></div><div class="content" data-v-ccf7ddec><div class="content-body" data-v-ccf7ddec><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ccf7ddec><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ccf7ddec data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/repository.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>库</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vitepress/recommend/video/movie.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>个人推荐</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>前端</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/vitepress/frontend/vue.html" data-v-43f1e123><!--[-->vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/vitepress/frontend/algo.html" data-v-43f1e123><!--[-->算法<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>后端</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuGroup" data-v-e7ea1737 data-v-69e747b5><p class="title" data-v-69e747b5>Node</p><!--[--><!--[--><div class="VPMenuLink" data-v-69e747b5 data-v-43f1e123><a class="VPLink link" href="/vitepress/backend/node/nest/0-介绍/" data-v-43f1e123><!--[-->nestjs<!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/vitepress/q&amp;a/html.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Q&A</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>其他</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/vitepress/other/game/魔兽/" data-v-43f1e123><!--[-->游戏<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ccf7ddec data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ccf7ddec data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ccf7ddec data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ccf7ddec data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-ccf7ddec><div class="divider-line" data-v-ccf7ddec></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-575e6a36><div class="curtain" data-v-575e6a36></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575e6a36><span class="visually-hidden" id="sidebar-aria-label" data-v-575e6a36> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-575e6a36><section class="VPSidebarItem level-0 has-active" data-v-575e6a36 data-v-b8d55f3b><!----><div class="items" data-v-b8d55f3b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/html/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>HTML</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/css/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>CSS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/js/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>JS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/chrome/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>浏览器原理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/performance/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>性能优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/vitepress/q&amp;a/network/" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>计算机网络</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>本页目录</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _vitepress_q&amp;a_network_" data-v-39a288b8><div><h1 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h1><h2 id="一、tcp与udp" tabindex="-1">一、TCP与UDP <a class="header-anchor" href="#一、tcp与udp" aria-label="Permalink to &quot;一、TCP与UDP&quot;">​</a></h2><h3 id="_1、说一说三次握手" tabindex="-1">1、说一说三次握手 <a class="header-anchor" href="#_1、说一说三次握手" aria-label="Permalink to &quot;1、说一说三次握手&quot;">​</a></h3><p>当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，我想很多人会这样回答：</p><p>首先很多人会先讲下握手的过程：</p><p>1、第一次握手：客户端给服务器发送一个 SYN 报文。<br> 2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。<br> 3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。<br> 4、服务器收到 ACK 报文之后，三次握手建立完成。</p><p>作用是为了确认双方的接收与发送能力是否正常。</p><p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以</strong>：</p><ul><li>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ul><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p><p>这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更详细一点，因为三次握手的过程中，双方是由很多状态的改变的，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</p><blockquote><p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后</p><ol><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</li><li>服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接</li></ol></blockquote><p><strong>三次握手的作用</strong></p><p>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：<br> 1、确认双方的接受能力、发送能力是否正常。<br> 2、指定自己的初始化序列号，为后面的可靠传送做准备。</p><p><strong>1、（ISN）是固定的吗</strong></p><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><p><strong>2、什么是半连接队列</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,</p><p><strong>3、三次握手过程中可以携带数据吗</strong></p><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p><h3 id="_2、说一说四次挥手" tabindex="-1">2、说一说四次挥手 <a class="header-anchor" href="#_2、说一说四次挥手" aria-label="Permalink to &quot;2、说一说四次挥手&quot;">​</a></h3><p>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好，我上次面试就被问了几个了，呵呵。我答错了，还以为自己答对了，当时还解释的头头是道，呵呵。</p><p>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li><li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ol><p>这里特别需要主要的就是<strong>TIME_WAIT</strong>这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。 这里我给出每个状态所包含的含义，有兴趣的可以看看。</p><blockquote><p>LISTEN - 侦听来自远方TCP端口的连接请求；<br> SYN-SENT -在发送连接请求后等待匹配的连接请求；<br> SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；<br> ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；<br> FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；<br> FIN-WAIT-2 - 从远程TCP等待连接中断请求；<br> CLOSE-WAIT - 等待从本地用户发来的连接中断请求；<br> CLOSING -等待远程TCP对连接中断的确认；<br> LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；<br> TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；<br> CLOSED - 没有任何连接状态；</p></blockquote><h3 id="_3、说一说post与get有哪些区别" tabindex="-1">3、说一说POST与GET有哪些区别 <a class="header-anchor" href="#_3、说一说post与get有哪些区别" aria-label="Permalink to &quot;3、说一说POST与GET有哪些区别&quot;">​</a></h3><p><strong>使用场景</strong><br> GET 用于获取资源，而 POST 用于传输实体主体。</p><p><strong>参数</strong><br> GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。<br> 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /test/demo_form.asp?name1=value1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&amp;name2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">value2</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTTP/1.1Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clipboardErrorCopied</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /test/demo_form.asp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> w3schools.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">value1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&amp;name2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">value2Copy</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clipboardErrorCopied</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>安全性</strong><br> 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。<br> GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。<br> 安全的方法除了 GET 之外还有：HEAD、OPTIONS。<br> 不安全的方法除了 POST 之外还有 PUT、DELETE。</p><p><strong>幂等性</strong><br> 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。<br> 所有的安全方法也都是幂等的。<br> 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /pageX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /pageX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /pageX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /pageX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clipboardErrorCopied</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /add_row</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Adds</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1nd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> row</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /add_row</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Adds</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2nd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> row</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /add_row</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Adds</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 3rd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rowCopy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clipboardErrorCopied</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DELETE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /idX/delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Returns</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> if</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> idX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exists</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DELETE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /idX/delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Returns</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 404</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> as</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> just</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> got</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deleted</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DELETE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /idX/delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Returns</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 404Copy</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clipboardErrorCopied</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>可缓存</strong></p><blockquote><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul></blockquote><p><strong>XMLHttpRequest</strong></p><blockquote><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：<br> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul></blockquote><h3 id="_4、面试官-说一说tcp与udp的区别" tabindex="-1">4、面试官：说一说TCP与UDP的区别 <a class="header-anchor" href="#_4、面试官-说一说tcp与udp的区别" aria-label="Permalink to &quot;4、面试官：说一说TCP与UDP的区别&quot;">​</a></h3><p><strong>TCP协议的主要特点</strong></p><p>（1）TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。<br> （2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；<br> （3）TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；<br> （4）TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；<br> （5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。</p><p><strong>TCP的可靠性原理</strong></p><p>可靠传输有如下两个特点:</p><ol><li>传输信道无差错,保证传输数据正确;</li><li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据; <ul><li>首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。</li><li>其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。</li><li>最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</li></ul></li></ol><p><strong>UDP协议特点:</strong></p><ol><li>UDP是无连接的传输层协议；</li><li>UDP使用尽最大努力交付，不保证可靠交付；</li><li>UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；</li><li>UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；</li><li>UDP支持一对一 一对多 多对多的交互通信；</li><li>UDP的首部开销小，只有８字节．</li></ol><p><strong>TCP和UDP的区别</strong></p><ol><li>TCP是可靠传输,UDP是不可靠传输;</li><li>TCP面向连接,UDP无连接;</li><li>TCP传输数据有序,UDP不保证数据的有序性;</li><li>TCP不保存数据边界,UDP保留数据边界;</li><li>TCP传输速度相对UDP较慢;</li><li>TCP有流量控制和拥塞控制,UDP没有;</li><li>TCP是重量级协议,UDP是轻量级协议;</li><li>TCP首部较长２０字节,UDP首部较短８字节;</li></ol><p><strong>基于TCP和UDP的常用协议</strong></p><p>HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议</p><p>TCP 和 UDP 的常用场景，这个问的好挺多的，例如我当时面试时，就被问过：QQ 登录的过程中，用到了 TCP 和 UDP，QQ 通话呢？</p><h3 id="_5-tcp的重传机制" tabindex="-1">5. TCP的重传机制 <a class="header-anchor" href="#_5-tcp的重传机制" aria-label="Permalink to &quot;5. TCP的重传机制&quot;">​</a></h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是基<strong>于确认信息</strong>。</p><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p><h3 id="_6-tcp的拥塞控制机制" tabindex="-1">6. TCP的拥塞控制机制 <a class="header-anchor" href="#_6-tcp的拥塞控制机制" aria-label="Permalink to &quot;6. TCP的拥塞控制机制&quot;">​</a></h3><p>TCP的拥塞控制机制主要是以下四种机制：</p><ul><li>慢启动（慢开始）</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><p><strong>（1）慢启动（慢开始）</strong></p><ul><li>在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</li><li><ul><li>当cnwd &lt; ssthresh，使用慢开始算法</li><li>当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法</li></ul></li></ul><p><strong>（2）拥塞避免</strong></p><ul><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: <img src="/vitepress/assets/img1.CemaZUGT.png" alt="img1"></li><li>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li></ul><p><strong>（3）快速重传</strong></p><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li></ul><p><strong>（4）快速恢复</strong></p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 <img src="/vitepress/assets/img2.C5gtE8e9.png" alt="img2"></li></ul><h3 id="_7-tcp的流量控制机制" tabindex="-1">7. TCP的流量控制机制 <a class="header-anchor" href="#_7-tcp的流量控制机制" aria-label="Permalink to &quot;7. TCP的流量控制机制&quot;">​</a></h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p><ul><li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li><li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li><li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li><li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li></ul><h3 id="_8-tcp的可靠传输机制" tabindex="-1">8. TCP的可靠传输机制 <a class="header-anchor" href="#_8-tcp的可靠传输机制" aria-label="Permalink to &quot;8. TCP的可靠传输机制&quot;">​</a></h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h2 id="二、websocket" tabindex="-1">二、WebSocket <a class="header-anchor" href="#二、websocket" aria-label="Permalink to &quot;二、WebSocket&quot;">​</a></h2><h3 id="_1-对-websocket-的理解" tabindex="-1">1. 对 WebSocket 的理解 <a class="header-anchor" href="#_1-对-websocket-的理解" aria-label="Permalink to &quot;1. 对 WebSocket 的理解&quot;">​</a></h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p><p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息</strong>。</p><p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p><p><strong>WebSocket 特点的如下：</strong></p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据‘’</li><li>建立在TCP协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li></ul><p><strong>Websocket的使用方法如下：</strong></p><p>在客户端中：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ws </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://localhost:9999&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在客户端与服务端建立连接后触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onopen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Connection open.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在服务端给客户端发来消息的时候触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res);       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印的是MessageEvent对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res.data);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印的是收到的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在客户端与服务端建立关闭后触发</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">evt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Connection closed.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_2-即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别" tabindex="-1">2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？ <a class="header-anchor" href="#_2-即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别" aria-label="Permalink to &quot;2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？&quot;">​</a></h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p><p><strong>短轮询的基本思路</strong>：浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p><p><strong>长轮询的基本思路</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p><strong>SSE 的基本思想</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p><p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p><p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p><p>对于这四种即使通信协议，从性能的角度来看：</p><p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p><p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p><p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p><p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p><h2 id="三、http协议" tabindex="-1">三、HTTP协议 <a class="header-anchor" href="#三、http协议" aria-label="Permalink to &quot;三、HTTP协议&quot;">​</a></h2><h3 id="_1-http-1-0-和-http-1-1-之间有哪些区别" tabindex="-1">1. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？ <a class="header-anchor" href="#_1-http-1-0-和-http-1-1-之间有哪些区别" aria-label="Permalink to &quot;1. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？&quot;">​</a></h3><p><strong>HTTP 1.0和 HTTP 1.1 有以下区别：</strong></p><ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul><h3 id="_2-http-1-1-和-http-2-0-的区别" tabindex="-1">2. HTTP 1.1 和 HTTP 2.0 的区别 <a class="header-anchor" href="#_2-http-1-1-和-http-2-0-的区别" aria-label="Permalink to &quot;2. HTTP 1.1 和 HTTP 2.0 的区别&quot;">​</a></h3><ul><li><strong>二进制协议</strong>：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>多路复用</strong>：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;【1】的问题。</li><li><strong>数据流</strong>：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>头信息压缩</strong>：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送</strong>：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><p><strong>【1】队头堵塞：</strong></p><blockquote><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><h3 id="_3-http和https协议的区别" tabindex="-1">3. HTTP和HTTPS协议的区别 <a class="header-anchor" href="#_3-http和https协议的区别" aria-label="Permalink to &quot;3. HTTP和HTTPS协议的区别&quot;">​</a></h3><p>HTTP和HTTPS协议的主要区别如下：</p><ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li></ul><h3 id="_4-get和post的请求的区别" tabindex="-1">4. GET和POST的请求的区别 <a class="header-anchor" href="#_4-get和post的请求的区别" aria-label="Permalink to &quot;4. GET和POST的请求的区别&quot;">​</a></h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li><strong>应用场景</strong>：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li><li><strong>是否缓存</strong>：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li><li><strong>发送的报文格式</strong>：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li><li><strong>安全性</strong>：Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li><li><strong>请求长度</strong>：浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li><li><strong>参数类型</strong>：post 的参数传递支持更多的数据类型。</li></ul><h3 id="_5-post和put请求的区别" tabindex="-1">5. POST和PUT请求的区别 <a class="header-anchor" href="#_5-post和put请求的区别" aria-label="Permalink to &quot;5. POST和PUT请求的区别&quot;">​</a></h3><ul><li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li><li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li></ul><h3 id="_6-常见的http请求头和响应头" tabindex="-1">6. 常见的HTTP请求头和响应头 <a class="header-anchor" href="#_6-常见的http请求头和响应头" aria-label="Permalink to &quot;6. 常见的HTTP请求头和响应头&quot;">​</a></h3><p><strong>HTTP Request Header 常见的请求头：</strong></p><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><p><strong>HTTP Responses Header 常见的响应头：</strong></p><ul><li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li><li>server:服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>content-type:表示后面的文档属于什么MIME类型</li></ul><p>常见的 Content-Type 属性值有以下四种：</p><p>（1）<code>application/x-www-form-urlencoded</code>：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）<code>text/plain</code>：纯文本格式，通常用于传输简单的文本文件。</p><p>（3）<code>application/json</code>：JSON 数据格式，广泛用于 Web API 和 RESTful 服务中传输数据。</p><p>（4）<code>multipart/form-data</code>：用于上传文件或多部分数据格式，常用于表单数据中包含文件的情况。</p><h2 id="四、dns协议介绍" tabindex="-1">四、DNS协议介绍 <a class="header-anchor" href="#四、dns协议介绍" aria-label="Permalink to &quot;四、DNS协议介绍&quot;">​</a></h2><h3 id="_1-dns-协议是什么" tabindex="-1">1. DNS 协议是什么 <a class="header-anchor" href="#_1-dns-协议是什么" aria-label="Permalink to &quot;1. DNS 协议是什么&quot;">​</a></h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p><h3 id="_2-dns同时使用tcp和udp协议" tabindex="-1">2. DNS同时使用TCP和UDP协议？ <a class="header-anchor" href="#_2-dns同时使用tcp和udp协议" aria-label="Permalink to &quot;2. DNS同时使用TCP和UDP协议？&quot;">​</a></h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p><p>（1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li></ul><h3 id="_3-dns完整的查询过程" tabindex="-1">3. DNS完整的查询过程 <a class="header-anchor" href="#_3-dns完整的查询过程" aria-label="Permalink to &quot;3. DNS完整的查询过程&quot;">​</a></h3><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>比如要查询 <a href="./.html">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="_4-迭代查询与递归查询" tabindex="-1">4. 迭代查询与递归查询 <a class="header-anchor" href="#_4-迭代查询与递归查询" aria-label="Permalink to &quot;4. 迭代查询与递归查询&quot;">​</a></h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="_5-dns-记录和报文" tabindex="-1">5. DNS 记录和报文 <a class="header-anchor" href="#_5-dns-记录和报文" aria-label="Permalink to &quot;5. DNS 记录和报文&quot;">​</a></h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>（Name，Value，Type，TTL）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p><ul><li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ul><h3 id="_6-dns-的解析过程" tabindex="-1">6. DNS 的解析过程？ <a class="header-anchor" href="#_6-dns-的解析过程" aria-label="Permalink to &quot;6. DNS 的解析过程？&quot;">​</a></h3><ol><li>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li><li>本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</li></ol><h2 id="五、网络模型" tabindex="-1">五、网络模型 <a class="header-anchor" href="#五、网络模型" aria-label="Permalink to &quot;五、网络模型&quot;">​</a></h2><h3 id="_1-osi七层模型" tabindex="-1">1. OSI七层模型 <a class="header-anchor" href="#_1-osi七层模型" aria-label="Permalink to &quot;1. OSI七层模型&quot;">​</a></h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。 <img src="/vitepress/assets/img3.DUN8Txxr.webp" alt="img3"></p><h4 id="_1-应用层" tabindex="-1">（1）应用层 <a class="header-anchor" href="#_1-应用层" aria-label="Permalink to &quot;（1）应用层&quot;">​</a></h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p><ul><li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li><li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。</li><li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li></ul><h4 id="_2-表示层" tabindex="-1">（2）表示层 <a class="header-anchor" href="#_2-表示层" aria-label="Permalink to &quot;（2）表示层&quot;">​</a></h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p><p>在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。</p><h4 id="_3-会话层" tabindex="-1">（3）会话层 <a class="header-anchor" href="#_3-会话层" aria-label="Permalink to &quot;（3）会话层&quot;">​</a></h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><h4 id="_4-传输层" tabindex="-1">（4）传输层 <a class="header-anchor" href="#_4-传输层" aria-label="Permalink to &quot;（4）传输层&quot;">​</a></h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p><h4 id="_5-网络层" tabindex="-1">（5）网络层 <a class="header-anchor" href="#_5-网络层" aria-label="Permalink to &quot;（5）网络层&quot;">​</a></h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p><h4 id="_6-数据链路层" tabindex="-1">（6）数据链路层 <a class="header-anchor" href="#_6-数据链路层" aria-label="Permalink to &quot;（6）数据链路层&quot;">​</a></h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p><p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p><h4 id="_7-物理层" tabindex="-1">（7）物理层 <a class="header-anchor" href="#_7-物理层" aria-label="Permalink to &quot;（7）物理层&quot;">​</a></h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><p><strong>OSI七层模型通信特点：对等通信</strong></p><p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p><h3 id="_2-tcp-ip五层协议" tabindex="-1">2. TCP/IP五层协议 <a class="header-anchor" href="#_2-tcp-ip五层协议" aria-label="Permalink to &quot;2. TCP/IP五层协议&quot;">​</a></h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下： <img src="/vitepress/assets/img4.DRqlQ5Z_.png" alt="img4"></p><ul><li><strong>应用层 (application layer)</strong>：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li><li><strong>传输层 (transport layer)</strong>：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议： <ul><li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li><li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li></ul></li><li><strong>网络层 (internet layer)</strong>：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li><li><strong>数据链路层 (data link layer)</strong>：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li><li><strong>物理层 (physical Layer)</strong>：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li></ul><p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p><p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 <img src="/vitepress/assets/img5.Dvz6huvd.webp" alt="img5"> 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： <img src="/vitepress/assets/img6.BZVGLsAg.webp" alt="img6"> 同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信： <img src="/vitepress/assets/img7.CzykLE0s.png" alt="img7"></p><h3 id="_3、谈谈你对域名缓存的了解" tabindex="-1">3、谈谈你对域名缓存的了解？ <a class="header-anchor" href="#_3、谈谈你对域名缓存的了解" aria-label="Permalink to &quot;3、谈谈你对域名缓存的了解？&quot;">​</a></h3><p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p><p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p><h3 id="_4、谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" tabindex="-1">4、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？ <a class="header-anchor" href="#_4、谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" aria-label="Permalink to &quot;4、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？&quot;">​</a></h3><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p><p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p><div class="language-ruby vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Connection:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">keep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">alive</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><h3 id="_5、https-的工作过程" tabindex="-1">5、HTTPS 的工作过程？ <a class="header-anchor" href="#_5、https-的工作过程" aria-label="Permalink to &quot;5、HTTPS 的工作过程？&quot;">​</a></h3><ol><li>客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；</li><li>服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；</li><li>客户端收到网站的证书之后要做下面的事情： <ul><li>验证证书的合法性；</li><li>果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；</li><li>用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。</li></ul></li><li>服务器接收到客户端传送来的信息，要做下面的事情： <ul><li>4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；</li><li>4.2 使用密钥加密消息；</li></ul></li><li>如果计算法 hash 值一致，握手成功。</li></ol><h3 id="_6、http-和-https-的区别" tabindex="-1">6、HTTP 和 HTTPS 的区别？ <a class="header-anchor" href="#_6、http-和-https-的区别" aria-label="Permalink to &quot;6、HTTP 和 HTTPS 的区别？&quot;">​</a></h3><ol><li>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li><li>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</li><li>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li><li>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</li></ol><h3 id="_7、https-的优缺点" tabindex="-1">7、HTTPS 的优缺点？ <a class="header-anchor" href="#_7、https-的优缺点" aria-label="Permalink to &quot;7、HTTPS 的优缺点？&quot;">​</a></h3><p><strong>优点：</strong></p><ol><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</li><li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ol><p><strong>缺点：</strong></p><ol><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li><li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；</li><li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</li></ol><h3 id="_8、什么是数字签名" tabindex="-1">8、什么是数字签名？ <a class="header-anchor" href="#_8、什么是数字签名" aria-label="Permalink to &quot;8、什么是数字签名？&quot;">​</a></h3><p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p><h3 id="_9、什么是数字证书" tabindex="-1">9、什么是数字证书？ <a class="header-anchor" href="#_9、什么是数字证书" aria-label="Permalink to &quot;9、什么是数字证书？&quot;">​</a></h3><p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p><h3 id="_10、cookie-和-session-有什么区别" tabindex="-1">10、Cookie 和 Session 有什么区别？ <a class="header-anchor" href="#_10、cookie-和-session-有什么区别" aria-label="Permalink to &quot;10、Cookie 和 Session 有什么区别？&quot;">​</a></h3><ol><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车。 当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。 这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。 有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li></ol><p>所以，总结一下：</p><p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。<br> Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-d4a0bba5><!--[--><!--]--><div class="edit-info" data-v-d4a0bba5><!----><div class="last-updated" data-v-d4a0bba5><p class="VPLastUpdated" data-v-d4a0bba5 data-v-7e05ebdb>更新时间: <time datetime="2024-12-25T02:20:41.000Z" data-v-7e05ebdb></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d4a0bba5><span class="visually-hidden" id="doc-footer-aria-label" data-v-d4a0bba5>Pager</span><div class="pager" data-v-d4a0bba5><a class="VPLink link pager-link prev" href="/vitepress/q&amp;a/performance/" data-v-d4a0bba5><!--[--><span class="desc" data-v-d4a0bba5>上一篇</span><span class="title" data-v-d4a0bba5>性能优化</span><!--]--></a></div><div class="pager" data-v-d4a0bba5><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div><!--[--><css-render-style></css-render-style><!--]--><!--]--></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"frontend_algo_index.md\":\"BDmv_UPS\",\"other_excerpt_index.md\":\"D6lKQ7xW\",\"index.md\":\"Dd5jj0v2\",\"backend_node_nest_0-介绍.md\":\"DjPZeDug\",\"other_game_魔兽_index.md\":\"CqhWePnR\",\"backend_node_nest_3-nestjs-cli.md\":\"DPcbQXWR\",\"other_career_index.md\":\"BlYotjRf\",\"q_a_chrome_block4.md\":\"Bwk5odv0\",\"frontend_vue_index.md\":\"DCg8YHv6\",\"q_a_chrome_block3.md\":\"Dis8XIdU\",\"q_a_chrome_block1.md\":\"D13jsPh-\",\"other_game_index.md\":\"CVwnPXZ2\",\"q_a_chrome_block2.md\":\"BJBvzZQl\",\"recommend_book_others_index.md\":\"DAj_7CKH\",\"recommend_video_anime_index.md\":\"CRogefrK\",\"recommend_video_movie_index.md\":\"D7dsNNKr\",\"q_a_js_block1-11-15.md\":\"Df1qgX_f\",\"q_a_network_block5.md\":\"M0Shii4o\",\"backend_node_nest_2-装饰器.md\":\"DIl-kJfK\",\"q_a_network_block4.md\":\"dnpVnfQV\",\"q_a_network_block1.md\":\"D4lWrpsT\",\"q_a_chrome_block9.md\":\"BjpeHBHI\",\"q_a_chrome_block6.md\":\"DdL74n1N\",\"q_a_chrome_block5.md\":\"DG9N445N\",\"backend_node_nest_1-ioc控制反转di依赖注入.md\":\"wbOqRXor\",\"q_a_js_block1-16-20.md\":\"CM-hoajB\",\"repository_index.md\":\"DHdAyoK6\",\"q_a_performance_index.md\":\"BlFBKguf\",\"q_a_chrome_block8.md\":\"pgPpgOD3\",\"q_a_network_block2.md\":\"B36AeUMK\",\"recommend_video_tv_index.md\":\"C7LCFlrH\",\"q_a_html_index.md\":\"dxyI6ciA\",\"q_a_network_block3.md\":\"CC7teqy-\",\"q_a_network_index.md\":\"DjUG-bE4\",\"q_a_js_block1-1-5.md\":\"BVusB2Zn\",\"recommend_book_technology_index.md\":\"CxMOCIhH\",\"q_a_css_index.md\":\"BETwzDdZ\",\"q_a_chrome_block7.md\":\"CshYskAZ\",\"q_a_js_block1-6-10.md\":\"DXXhF5Jh\",\"q_a_js_index.md\":\"_9Oj3dTE\",\"q_a_chrome_index.md\":\"BnRJnYz_\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"My Awesome Project\",\"description\":\"A VitePress Site\",\"base\":\"/vitepress/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"库\",\"link\":\"/repository\",\"activeMatch\":\"repository\"},{\"text\":\"个人推荐\",\"link\":\"/recommend/video/movie\",\"activeMatch\":\"recommend\"},{\"text\":\"前端\",\"activeMatch\":\"frontend\",\"items\":[{\"text\":\"vue\",\"link\":\"/frontend/vue\"},{\"text\":\"算法\",\"link\":\"/frontend/algo\"}]},{\"text\":\"后端\",\"activeMatch\":\"backend\",\"items\":[{\"text\":\"Node\",\"items\":[{\"text\":\"nestjs\",\"link\":\"/backend/node/nest/0-介绍/\"}]}]},{\"text\":\"Q&A\",\"link\":\"/q&a/html\",\"activeMatch\":\"q&a\"},{\"text\":\"其他\",\"activeMatch\":\"other\",\"items\":[{\"text\":\"游戏\",\"link\":\"/other/game/魔兽/\"}]}],\"sidebar\":{\"/recommend/\":[{\"text\":\"阅读\",\"items\":[{\"text\":\"技术\",\"link\":\"/recommend/book/technology/\"},{\"text\":\"其他\",\"link\":\"/recommend/book/others/\"}]},{\"text\":\"影视\",\"items\":[{\"text\":\"电影\",\"link\":\"/recommend/video/movie/\"},{\"text\":\"电视剧\",\"link\":\"/recommend/video/tv/\"},{\"text\":\"动漫\",\"link\":\"/recommend/video/anime/\"}]}],\"/backend/\":[{\"text\":\"介绍\",\"link\":\"/backend/node/nest/0-介绍\"},{\"text\":\"前置知识\",\"items\":[{\"text\":\"IOC控制反转 DI依赖注入\",\"link\":\"/backend/node/nest/1-IOC控制反转DI依赖注入\"},{\"text\":\"装饰器\",\"link\":\"/backend/node/nest/2-装饰器\"},{\"text\":\"Nestjs cli\",\"link\":\"/backend/node/nest/3-nestjs-cli\"}]}],\"/q&a/\":[{\"text\":\"HTML\",\"link\":\"/q&a/html/\"},{\"text\":\"CSS\",\"link\":\"/q&a/css/\"},{\"text\":\"JS\",\"link\":\"/q&a/js/\"},{\"text\":\"浏览器原理\",\"link\":\"/q&a/chrome/\"},{\"text\":\"性能优化\",\"link\":\"/q&a/performance/\"},{\"text\":\"计算机网络\",\"link\":\"/q&a/network/\"}],\"/other/\":[{\"text\":\"魔兽\",\"link\":\"/other/game/魔兽/\"}]},\"search\":{\"provider\":\"local\"},\"outline\":{\"level\":\"deep\",\"label\":\"本页目录\"},\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"lastUpdated\":{\"text\":\"更新时间\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>